package utils

import (
	"bytes"
	"testing"

	"github.com/ethereum/go-ethereum/common/hexutil"
)

const (
	privateKey = "0x0042000000000000000000000000000000000000000000000000000000000000"
	publicKey  = "0x041e1837ef0d195188357571b5e5545b122e8f0967fda724203eb2561cce9" +
		"7285ef82b2d4f9ef1079f6c4b5b8356e23242e958b6d749a6b5681a4103566bdc5a89"

	remotePubKey = "0x04ead218590119e8876b29146ff89ca61770c4edbbf97d38ce385ed281d8a6b230" +
		"28af61281fd35e2fa7002523acc85a429cb06ee6648325389f59edfce1405141"

	// sharedKey is generated by privatekey + remotePubkey
	sharedKey = "0x6f20ecf64482f580f1ab39df75cc14f6d5ceb9d878094d7c2970656c3561a9e1"

	plainText  = "The dog ate my homework"
	cipherText = "000000000000000000000000f63f4e75a3cf543c88a449d18ba57d6f7876ab" +
		"41f904c104b0c94be4f070e98f6f310789970082"
)

// sampleReader should help generate the same key everytime its used.
// Cypto/rand reader is recommended for the real use case.
type sampleReader int

func (s sampleReader) Read(p []byte) (int, error) {
	return int(s), nil
}

// TestDataEncryptionAndDecryption tests the secure data encryption and decryption
// using a sharedkey key generated via diffie-hellman key exchange.
func TestDataEncryptionAndDecryption(t *testing.T) {
	reader := sampleReader(5)
	prikey, err := GeneratePrivKey(reader)
	if err != nil {
		t.Fatalf("expected no error but found %q", err)
	}

	// confirm generated private key matches the expected deterministic key.
	priKeyStr := hexutil.Encode(prikey.Bytes())
	if priKeyStr != privateKey {
		t.Fatalf("expected private key to be %q but found %q", privateKey, priKeyStr)
	}

	// confirm generated public key matches the expected deterministic key.
	pubkey := prikey.PubKeyToHexString()
	if pubkey != publicKey {
		t.Fatalf("expected public key to be %q but found %q", publicKey, pubkey)
	}

	key, err := prikey.ComputeSharedKey(remotePubKey)
	if err != nil {
		t.Fatalf("expected no error but found %q", err)
	}
	keyStr := hexutil.Encode(key)
	// confirm generated shared key matches the expected deterministic key.
	if keyStr != sharedKey {
		t.Fatalf("expected shared key to be %q but found %q", sharedKey, keyStr)
	}

	encyptedText, err := EncryptAES(key, []byte(plainText))
	if err != nil {
		t.Fatalf("expected no error but found %q", err)
	}

	// confirm generated encrypted text matches the expected one.
	if encyptedText != cipherText {
		t.Fatalf("expected encrypted text to be %q but found %q", cipherText, encyptedText)
	}

	decryptedText, err := DecryptAES(key, encyptedText)
	if err != nil {
		t.Fatalf("expected no error but found %q", err)
	}

	// confirm the decrypted text matches the origin plaintext.
	if !bytes.Equal(decryptedText, []byte(plainText)) {
		t.Fatalf("expected encrypted text to be %q but found %q", cipherText, encyptedText)
	}
}
