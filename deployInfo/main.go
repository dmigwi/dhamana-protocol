// Copyright (c) 2023 Migwi Ndung'u
// See LICENSE for details.

package main

import (
	"bytes"
	"fmt"
	"html/template"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

const (
	// regexString defines the regex string used to extract the required data from
	// from the deployment log.
	// regexString = `("%s"):(["]*[\w]*["]*)`
	regexString = `(> %s:[[:space:]']*)([\w]*)`

	// deploymentPkg defines the folder of the auto-generated configuration files.
	deploymentPkg = "deployment"

	// deploymentFile auto-generated file name.
	deploymentFile = "deployment.go"

	// deploymentConfigTmpl template used to fill in the required config.
	deploymentConfigTmpl = `
// {{ .FuncName }} {{ .Comment }}
func {{ .FuncName }}() ({{ .ReturnType }}) {
	return {{ print .Value }}
}
`
)

// FieldInfo defines the properties of the auto generated file functions using the
// the field names of the properties extracted from the truffle deployment logs.
type FieldInfo struct {
	// Identifier defines field name as used in truffle deployment log.
	Identifier string
	// FuncName defines the function name to be used in the generated file.
	FuncName string
	// ReturnType defines the data type to be returned in the generated file.
	ReturnType string
	// Comment defines description of the function in the generated file.
	Comment string
	// Value defines the actual value to be returned once regex expressions are
	// evaluated for each Identifier.
	Value string
}

var (
	// deploymentFileHeader defines the header part of the auto-genarated file.
	deploymentFileHeader = `// Copyright (c) 2023 Migwi Ndung'u
// See LICENSE for details.

// Deployment configuration file is Auto generated - DO NOT EDIT.
// Code generated by "deployInfo" tool using the truffle deployment log;

package xxxx
`
	fields = []FieldInfo{
		{
			Identifier: "Network name",
			FuncName:   "GetNetwork",
			ReturnType: "string",
			Comment:    "returns the network used to make the deployment.",
		}, {
			Identifier: "Block gas limit",
			FuncName:   "GetBlockGasLimit",
			ReturnType: "uint64",
			Comment:    "returns the block gas limit set during deployment.",
		}, {
			Identifier: "Network id",
			FuncName:   "GetChainID",
			ReturnType: "uint64",
			Comment:    "returns the chain ID of the network used to make the deployment.",
		}, {
			Identifier: "contract address",
			FuncName:   "GetContractAddress",
			ReturnType: "string",
			Comment:    "returns the address of the deployed contract.",
		}, {
			Identifier: "transaction hash",
			FuncName:   "GetTransactionHash",
			ReturnType: "string",
			Comment:    "returns the tx hash when the contract we deployed.",
		}, {
			Identifier: "block timestamp",
			FuncName:   "GetDeploymentTime",
			ReturnType: "uint64",
			Comment:    "returns the timestamp in seconds when the contract was actually deployed ",
		}, {
			Identifier: "block number",
			FuncName:   "GetDeploymentBlock",
			ReturnType: "uint64",
			Comment:    "returns the block number when the contract was actually deployed ",
		},
	}
)

func main() {
	// deploymentFilePath defines the path where npm stores the deployment log
	// information on deploying a contract.
	deploymentFilePath := os.Args[1]
	if deploymentFilePath == "" {
		log.Fatal("A valid truffle deployment file path is required")
	}

	data, err := os.ReadFile(deploymentFilePath)
	if err != nil {
		log.Fatalf("Unable to read deployment log file at %v", deploymentFilePath)
	}

	// Create a new template and parse the deploymentConfig into it.
	t := template.Must(template.New(deploymentFile).Parse(deploymentConfigTmpl))

	buf := bytes.NewBufferString(deploymentFileHeader)

	// Use the regex
	for i, info := range fields {
		expression := fmt.Sprintf(regexString, info.Identifier)
		strMatched := regexp.MustCompile(expression).FindAllString(string(data), -1)

		if len(strMatched) == 0 {
			log.Fatalf("could not locate data for identifier: %s", info.Identifier)
		}

		v := strings.SplitAfter(strMatched[0], ":")
		vStr := strings.TrimSpace(v[1])
		fields[i].Value = vStr
		if info.ReturnType == "string" {
			fields[i].Value = fmt.Sprintf("%q", vStr)
		}

		err := t.Execute(buf, fields[i])
		if err != nil {
			log.Fatalf("executing template: %v", err)
		}
	}

	// creates a package name unique to the deployment network used.
	netpkg := regexp.MustCompile(`[^[:alnum:]]`).ReplaceAllString(fields[0].Value, "")

	// replace the place holder package name with correct package name
	escapedData := strings.ReplaceAll(buf.String(), "xxxx", netpkg)

	// replace the escaped comma character and convert it back to bytes
	escapedData = strings.ReplaceAll(escapedData, "&#34;", `"`)

	// replace the escaped signle quote character and convert it back to bytes
	escapedData = strings.ReplaceAll(escapedData, "&#39;", ``)

	path := filepath.Join("client", deploymentPkg, netpkg)
	if _, err = os.Stat(path); err != nil {
		err := os.MkdirAll(path, 0o0700)
		if err != nil {
			log.Fatalf("executing template: %v", err)
		}
	}

	// Write the file in its respective package within the client main package.
	path = filepath.Join(path, deploymentFile)
	if err = os.WriteFile(path, []byte(escapedData), 0o0700); err != nil {
		log.Fatalf("writing file %s failed", path)
	}
	log.Printf("Log deployment information has me written to : %v", path)
}
